{"name":"Surrounded","tagline":"Gives an object implicit access to other objects in it's environment.","body":"# ![Surrounded](http://saturnflyer.github.io/surrounded/images/surrounded.png \"Surrounded\")\r\n## Be in control of business logic.\r\n\r\n[![Build Status](https://travis-ci.org/saturnflyer/surrounded.png?branch=master)](https://travis-ci.org/saturnflyer/surrounded)\r\n[![Code Climate](https://codeclimate.com/github/saturnflyer/surrounded.png)](https://codeclimate.com/github/saturnflyer/surrounded)\r\n[![Coverage Status](https://coveralls.io/repos/saturnflyer/surrounded/badge.png)](https://coveralls.io/r/saturnflyer/surrounded)\r\n[![Gem Version](https://badge.fury.io/rb/surrounded.png)](http://badge.fury.io/rb/surrounded)\r\n\r\nSurrounded is designed to help you better manage your business logic by keeping cohesive behaviors together. Bring objects together to implement your use cases and gain behavior only when necessary.\r\n\r\n## How to think about your objects\r\n\r\nFirst, name the problem you're solving. Then, break down your problem into responsible roles.\r\n\r\nUse your problem name as a class and extend it with `Surrounded::Context`\r\n\r\nIt might look like this:\r\n\r\n```ruby\r\nclass Employment\r\n  extend Surrounded::Context\r\n\r\n  role :boss\r\n  role :employee\r\nend\r\n```\r\n\r\nIn your application, you'll initialize this class with objects to play the roles that you've defined, so you'll need to specify which role players will use which role.\r\n\r\n```ruby\r\nclass Employment\r\n  extend Surrounded::Context\r\n\r\n  initialize :employee, :boss\r\n\r\n  role :boss\r\n  role :employee\r\nend\r\n```\r\n\r\nHere, you've specified the order when initializing so you can use it like this:\r\n\r\n```ruby\r\nuser1 = User.find(1)\r\nuser2 = User.find(2)\r\ncontext = Employment.new(user1, user2)\r\n```\r\n\r\nThat ensures that `user1` will become (and have all the features of) the `employee` and `user2` will become (and have all the features of) the `boss`.\r\n\r\nThere are 2 things left to do:\r\n\r\n1. define behaviors for each role and\r\n2. define how you can trigger their actions\r\n\r\nCurrently initializing contexts does not require the use of keyword arguments, _but it will in the future_.\r\n\r\nYou should consider using explicit names when initialize now by using `keyword_initialize`:\r\n\r\n```ruby\r\nclass Employment\r\n  extend Surrounded::Context\r\n\r\n  keyword_initialize :employee, :boss\r\nend\r\n\r\nuser1 = User.find(1)\r\nuser2 = User.find(2)\r\ncontext = Employment.new(employee: user1, boss: user2)\r\n```\r\n\r\nThis will allow you to prepare your accessing code to use keywords.\r\n\r\n## Defining behaviors for roles\r\n\r\nBehaviors for your roles are easily defined just like you define a method. Provide your role a block and define methods there.\r\n\r\n```ruby\r\nclass Employment\r\n  extend Surrounded::Context\r\n\r\n  initialize :employee, :boss\r\n\r\n  role :boss\r\n\r\n  role :employee do\r\n    def work_weekend\r\n      if fed_up?\r\n        quit\r\n      else\r\n        schedule_weekend_work\r\n      end\r\n    end\r\n\r\n    def quit\r\n      say(\"I'm sick of this place, #{boss.name}!\")\r\n      stomp\r\n      throw_papers\r\n      say(\"I quit!\")\r\n    end\r\n\r\n    def schedule_weekend_work\r\n      # ...\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nIf any of your roles don't have special behaviors, like `boss`, you don't need to specify it. Your `initialize` setup will handle assiging who's who when this context is used.\r\n\r\n```ruby\r\nclass Employment\r\n  extend Surrounded::Context\r\n\r\n  initialize :employee, :boss\r\n\r\n  role :employee do\r\n    #...\r\n  end\r\nend\r\n```\r\n\r\n## Triggering interactions\r\n\r\nYou'll need to define way to trigger these behaviors to occur so that you can use them.\r\n\r\n```ruby\r\ncontext = Employment.new(user1, user2)\r\n\r\ncontext.plan_weekend_work\r\n```\r\n\r\nThe method you need is defined as an instance method in your context, but before that method will work as expected you'll need to mark it as a trigger.\r\n\r\n```ruby\r\nclass Employment\r\n  extend Surrounded::Context\r\n\r\n  initialize :employee, :boss\r\n\r\n  def plan_weekend_work\r\n    employee.work_weekend\r\n  end\r\n  trigger :plan_weekend_work\r\n\r\n  role :employee do\r\n    #...\r\n  end\r\nend\r\n```\r\n\r\nTrigger methods are different from regular instance methods in that they apply behaviors from the roles to the role players.\r\nA regular instance method just does what you define. But a trigger will make your role players come alive with their behaviors.\r\n\r\nYou may find that the code for your triggers is extremely simple and is merely creating a method to tell a role player what to do. If you find you have many methods like this:\r\n\r\n```ruby\r\n  def plan_weekend_work\r\n    employee.work_weekend\r\n  end\r\n  trigger :plan_weekend_work\r\n```\r\n\r\nYou can shorten it to:\r\n\r\n```ruby\r\n  trigger :plan_weekend_work do\r\n    employee.work_weekend\r\n  end\r\n```\r\n\r\nBut it can be even simpler and follows the same pattern provided by Ruby's standard library Forwardable:\r\n\r\n```ruby\r\n  # The first argument is the role to receive the messaged defined in the second argument.\r\n  # The third argument is optional and if provided will be the name of the trigger method on your context instance.\r\n  forward_trigger :employee, :work_weekend, :plan_weekend_work\r\n\r\n  # Alternatively, you can use an API similar to that of the `delegate` method from Forwardable\r\n  forwarding [:work_weekend] => :employee\r\n```\r\n\r\nThe difference between `forward_trigger` and `forwarding` is that the first accepts an alternative method name for the context instance method. There's more on this below in the \"Overview in code\" section, or see `lib/surrounded/context/forwarding.rb`.\r\n\r\nThere's one last thing to make this work.\r\n\r\n## Getting your role players ready\r\n\r\nYou'll need to include `Surrounded` in the classes of objects which will be role players in your context.\r\n\r\nIt's as easy as:\r\n\r\n```ruby\r\nclass User\r\n  include Surrounded\r\n\r\n  # ...\r\nend\r\n```\r\n\r\nThis gives each of the objects the ability to understand its context and direct access to other objects in the context.\r\n\r\n## Why is this valuable?\r\n\r\nBy creating environments which encapsulate roles and all necessary behaviors, you will be better able to isolate the logic of your system. A `user` in your system doesn't have all possible behaviors defined in its class, it gains the behaviors only when they are necessary.\r\n\r\nThe objects that interact have their behaviors defined and available right where they are needed. Implementation is in proximity to necessity. The behaviors you need for each role player are highly cohesive and are coupled to their use rather than being coupled to the class of an object which might use them at some point.\r\n\r\n# Deeper Dive\r\n\r\n## Create encapsulated environments for your objects.\r\n\r\nTypical initialization of an environment, or a Context in DCI, has a lot of code. For example:\r\n\r\n```ruby\r\nclass Employment\r\n\r\n  attr_reader :employee, :boss\r\n  private :employee, :boss\r\n  def initialize(employee, boss)\r\n    @employee = employee.extend(Employee)\r\n    @boss = boss\r\n  end\r\n\r\n  module Employee\r\n    # extra behavior here...\r\n  end\r\nend\r\n```\r\n\r\nThis code allows the Employment class to create instances where it will have an `employee` and a `boss` role internally. These are set to `attr_reader`s and are made private.\r\n\r\nThe `employee` is extended with behaviors defined in the `Employee` module, and in this case there's no extra stuff for the `boss` so it doesn't get extended with anything.\r\n\r\nMost of the time you'll follow a pattern like this. Some objects will get extra behavior and some won't. The modules that you use to provide the behavior will match the names you use for the roles to which you assign objects.\r\n\r\nBy adding `Surrounded::Context` you can shortcut all this work.\r\n\r\n```ruby\r\nclass Employment\r\n  extend Surrounded::Context\r\n  \r\n  initialize(:employee, :boss)\r\n\r\n  module Employee\r\n    # extra behavior here...\r\n  end\r\nend\r\n```\r\n\r\nSurrounded gives you an `initialize` class method which does all the setup work for you.\r\n\r\n## Managing Roles\r\n\r\n_I don't want to use modules. Can't I use something like SimpleDelegator?_\r\n\r\nWell, it just so happens that you can. This code will work just fine:\r\n\r\n```ruby\r\nclass Employment\r\n  extend Surrounded::Context\r\n  \r\n  initialize(:employee, :boss)\r\n\r\n  class Employee < SimpleDelegator\r\n    # extra behavior here...\r\n  end\r\nend\r\n```\r\n\r\nInstead of extending the `employee` object, Surrounded will run `Employee.new(employee)` to create the wrapper for you. You'll need to include the `Surrounded` module in your wrapper, but we'll get to that.\r\n\r\nBut the syntax can be even simpler than that if you want.\r\n\r\n```ruby\r\nclass Employment\r\n  extend Surrounded::Context\r\n  \r\n  initialize(:employee, :boss)\r\n\r\n  role :employee do\r\n    # extra behavior here...\r\n  end\r\nend\r\n```\r\n\r\nBy default, this code will create a module for you named `Employee`. If you want to use a wrapper, you can do this:\r\n\r\n```ruby\r\nclass Employment\r\n  extend Surrounded::Context\r\n  \r\n  initialize(:employee, :boss)\r\n\r\n  wrap :employee do\r\n    # extra behavior here...\r\n  end\r\nend\r\n```\r\n\r\nBut if you're making changes and you decide to move from a module to a wrapper or from a wrapper to a module, you'll need to change that method call. Instead, you could just tell it which type of role to use:\r\n\r\n```ruby\r\nclass Employment\r\n  extend Surrounded::Context\r\n  \r\n  initialize(:employee, :boss)\r\n\r\n  role :employee, :wrapper do\r\n    # extra behavior here...\r\n  end\r\nend\r\n```\r\n\r\nThe default available types are `:module`, `:wrap` or `:wrapper`, and `:interface`. We'll get to `interface` below. The `:wrap` and `:wrapper` types are the same and they'll both create classes which inherit from SimpleDelegator _and_ include Surrounded for you.\r\n\r\nThese are minor little changes which highlight how simple it is to use Surrounded.\r\n\r\n_Well... I want to use [Casting](https://github.com/saturnflyer/casting) so I get the benefit of modules without extending objects. Can I do that?_\r\n\r\nYup. The ability to use Casting is built-in. If the objects you provide to your context respond to `cast_as` then Surrounded will use that.\r\n\r\n_Ok. So is that it?_\r\n\r\nThere's a lot more. Let's look at the individual objects and what they need for this to be valuable...\r\n\r\n## Objects' access to their environments\r\n\r\nAdd `Surrounded` to your objects to give them awareness of other objects.\r\n\r\n```ruby\r\nclass User\r\n  include Surrounded\r\nend\r\n```\r\n\r\nNow the `User` instances will be able to implicitly access objects in their environment.\r\n\r\nVia `method_missing` those `User` instances can access a `context` object it stores in an internal collection. \r\n\r\nInside of the `Employment` context we saw above, the `employee` and `boss` objects are instances of `User` for this example.\r\n\r\nBecause the `User` class includes `Surrounded`, the instances of that class will be able to access other objects in the same context implicitly.\r\n\r\nLet's make our context look like this:\r\n\r\n```ruby\r\nclass Employment\r\n  # other stuff from above is still here...\r\n\r\n  def plan_weekend_work\r\n    employee.quit\r\n  end\r\n\r\n  role :employee do\r\n    def quit\r\n      say(\"I'm sick of this place, #{boss.name}!\")\r\n      stomp\r\n      throw_papers\r\n      say(\"I quit!\")\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nWhat's happening in there is that when the `plan_weekend_work` method is called on the instance of `Employment`, the `employee` has the ability to refer to `boss` because it is in the same context, e.g. the same environment.\r\n\r\nThe behavior defined in the `Employee` module assumes that it may access other objects in it's local environment. The `boss` object, for example, is never explicitly passed in as an argument.\r\n\r\nWhat `Surrounded` does for us is to make the relationship between objects and gives them the ability to access each other. Adding new or different roles to the context now only requires that we add them to the context and nothing else. No explicit references must be passed to each individual method. The objects are aware of the other objects around them and can refer to them by their role name.\r\n\r\nI didn't mention how the context is set, however.\r\n\r\n## Tying objects together\r\n\r\nYour context will have methods of it's own which will trigger actions on the objects inside, but we need those trigger methods to set the accessible context for each of the contained objects.\r\n\r\nHere's an example of what we want:\r\n\r\n```ruby\r\nclass Employment\r\n  # other stuff from above is still here...\r\n\r\n  def plan_weekend_work\r\n    employee.store_context(self)\r\n    employee.quit\r\n    employee.remove_context\r\n  end\r\n\r\n  role :employee do\r\n    def quit\r\n      say(\"I'm sick of this place, #{boss.name}!\")\r\n      stomp\r\n      throw_papers\r\n      say(\"I quit!\")\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nNow that the `employee` has a reference to the context, it won't blow up when it hits `boss` inside that `quit` method.\r\n\r\nWe saw how we were able to clear up a lot of that repetitive work with the `initialize` method, so this is how we do it here:\r\n\r\n```ruby\r\nclass Employment\r\n  # other stuff from above is still here...\r\n\r\n  trigger :plan_weekend_work do\r\n    employee.quit\r\n  end\r\n\r\n  role :employee do\r\n    def quit\r\n      say(\"I'm sick of this place, #{boss.name}!\")\r\n      stomp\r\n      throw_papers\r\n      say(\"I quit!\")\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nBy using this `trigger` keyword, our block is the code we care about, but internally the method is created to first set all the objects' current contexts.\r\n\r\nThe context will also store the triggers so that you can, for example, provide details outside of the environment about what triggers exist.\r\n\r\n```ruby\r\ncontext = Employment.new(current_user, the_boss)\r\ncontext.triggers #=> [:plan_weekend_work]\r\n```\r\n\r\nYou might find that useful for dynamically defining user interfaces.\r\n\r\nSometimes I'd rather not use this DSL, however. I want to just write regular methods. \r\n\r\nWe can do that too. You'll need to opt in to this by specifying `trigger :your_method_name` for the methods you want to use.\r\n\r\n```ruby\r\nclass Employment\r\n  # other stuff from above is still here...\r\n\r\n  def plan_weekend_work\r\n    employee.quit\r\n  end\r\n  trigger :plan_weekend_work\r\n  \r\n  # or in Ruby 2.x\r\n  trigger def plan_weekend_work\r\n    employee.quit\r\n  end\r\n\r\n  role :employee do\r\n    def quit\r\n      say(\"I'm sick of this place, #{boss.name}!\")\r\n      stomp\r\n      throw_papers\r\n      say(\"I quit!\")\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThis will allow you to write methods like you normally would. They are aliased internally with a prefix and the method name that you use is rewritten to add and remove the context for the objects in this context. The public API of your class remains the same, but the extra feature of wrapping your method is handled for you.\r\n\r\nThis works like Ruby's `public`,`protected`, and `private` keywords in that you can send symbols of method names to it. But `trigger` does not alter the parsing of the document like those core keywords do. In other words, you can't merely type `trigger` on one line, and have methods added afterward be treated as trigger methods.\r\n\r\n## Access Control for Triggers\r\n\r\nIf you decide to build a user interface from the available triggers, you'll find you need to know what triggers are available.\r\n\r\nFortunately, you can make it easy.\r\n\r\nBy running `protect_triggers` you'll be able to define when triggers may or may not be run. You can still run them, but they'll raise an error. Here's an example.\r\n\r\n```ruby\r\nclass Employment\r\n  extend Surrounded::Context\r\n  protect_triggers\r\n  \r\n  def plan_weekend_work\r\n    employee.quit\r\n  end\r\n  trigger :plan_weekend_work\r\n  \r\n  disallow :plan_weekend_work do\r\n    employee.bank_balance > 1000000\r\n  end\r\nend\r\n```\r\n\r\nThen, when the employee role's `bank_balance` is greater than `1000000`, the available triggers won't include `:plan_weekend_work`.\r\n\r\nYou can compare the instance of the context by listing `all_triggers` and `triggers` to see what could be possible and what's currently possible.\r\n\r\nAlternatively, if you just want to define your own methods without the DSL using `disallow`, you can just follow the pattern of `disallow_#{method_name}?` when creating your own protection.\r\n\r\nIn fact, that's exactly what happens with the `disallow` keyword. After using it here, we'd have a `disallow_plan_weekend_work?` method defined.\r\n\r\nIf you call the disallowed trigger directly, you'll raise an `Employment::AccessError` exception and the code in your trigger will not be run. You may rescue from that or you may rescue from `Surrounded::Context::AccessError` although you should prefer to use the error name from your own class.\r\n\r\n## Restricting return values\r\n\r\n_Tell, Don't Ask_ style programming can better be enforced by following East-oriented Code principles. This means that the return values from methods on your objects should not provide information about their internal state. Instead of returning values, you can enforce that triggers return the context object. This forces you to place context responsiblities inside the context and prevents leaking the details and responsiblities outside of the system.\r\n\r\nHere's how you enforce it:\r\n\r\n```ruby\r\nclass Employment\r\n  extend Surrounded::Context\r\n  east_oriented_triggers\r\nend\r\n```\r\n\r\nThat's it.\r\n\r\nWith that change, any trigger you define will execute the block you provide and return `self`, being the instance of the context.\r\n\r\n## Where roles exist\r\n\r\nBy using `Surrounded::Context` you are declaring a relationship between the objects inside playing your defined roles.\r\n\r\nBecause all the behavior is defined internally and only relevant internally, those relationships don't exist outside of the environment.\r\n\r\nSurrounded makes all of your role modules and classes private constants. It's not a good idea to try to reuse behavior defined for one context in another area.\r\n\r\n## The role DSL\r\n\r\nUsing the `role` method to define modules and classes takes care of the setup for you. This way you can swap between implementations:\r\n\r\n```ruby\r\n\r\n  # this uses modules which include Surrounded\r\n  role :source do\r\n    def transfer\r\n      self.balance -= amount\r\n      destination.balance += amount\r\n      self\r\n    end\r\n  end\r\n\r\n  # this uses SimpleDelegator and Surrounded\r\n  role :source, :wrap do\r\n    def transfer\r\n      self.balance -= amount\r\n      destination.balance += amount\r\n      __getobj__\r\n    end\r\n  end\r\n\r\n  # this uses a special interface object which pulls\r\n  # methods from a module and applies them to your object.\r\n  role :source, :interface do\r\n    def transfer\r\n      self.balance -= amount\r\n      # not able to access destination unless the object playing source is Surrounded\r\n      destination.balance += amount\r\n      self\r\n    end\r\n  end\r\n```\r\n\r\nThe `:interface` option is a special object which has all of the standard Object methods removed (excepting ones like `__send__` and `object_id`) so that other methods will be pulled from the ones that you define, or from the object it attempts to proxy.\r\n\r\nNotice that the `:interface` allows you to return `self` whereas the `:wrap` acts more like a wrapper and forces you to deal with that shortcoming by using it's wrapped-object-accessor method: `__getobj__`.\r\n\r\nThe downside of using an interface is that it is still a wrapper and it only has access to the other objects in the context if the wrapped object already includes Surrounded. All of your defined role methods are executed in the context of the object playing the role, but the interface has it's own identity.\r\n\r\nIf you'd like to choose one and use it all the time, you can set the default:\r\n\r\n```ruby\r\nclass MoneyTransfer\r\n  extend Surrounded::Context\r\n\r\n  self.default_role_type = :interface # also :wrap, :wrapper, or :module\r\n\r\n  role :source do\r\n    def transfer\r\n      self.balance -= amount\r\n      destination.balance += amount\r\n      self\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nOr, if you like, you can choose the default for your entire project:\r\n\r\n```ruby\r\nSurrounded::Context.default_role_type = :interface\r\n\r\nclass MoneyTransfer\r\n  extend Surrounded::Context\r\n\r\n  role :source do\r\n    def transfer\r\n      self.balance -= amount\r\n      destination.balance += amount\r\n      self\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n## Working with collections\r\n\r\nIf you want to use an Array of objects (for example) as a role player in your context,\r\nyou may do so. If you want each item in your collection to gain behavior, you merely need to\r\ncreate a role for the items.\r\n\r\nSurrounded will attempt to guess at the singular role name. For example, a role player named `members` would\r\nbe given the behaviors from a `Members` behavior module or class. Each item in your `members` collection\r\nwould be given behavior from a `Member` behavior module or class if you create one.\r\n\r\n```ruby\r\nclass Organization\r\n  extend Surrounded::Context\r\n\r\n  initialize_without_keywords :leader, :members\r\n  \r\n  role :members do\r\n    # special behavior for the collection\r\n  end\r\n  \r\n  role :member do\r\n    # special behavior to be applied to each member in the collection\r\n  end  \r\nend\r\n```\r\n\r\n## Reusing context objects\r\n\r\nIf you create a context object and need to use the same type of object with new role players, you may use the `rebind` method. It will clear any instance_variables from your context object and map the given objects to their names:\r\n\r\n```ruby\r\ncontext = Employment.new(current_user, the_boss)\r\ncontext.rebind(employee: another_user, boss: someone_else) # same context, new players\r\n```\r\n\r\n## Overview in code\r\n\r\nHere's a view of the possibilities in code.\r\n\r\n```ruby\r\n# set default role type for *all* contexts in your program\r\nSurrounded::Context.default_role_type = :module # also :wrap, :wrapper, or :interface\r\n\r\nclass ActiviatingAccount\r\n  extend Surrounded::Context\r\n  \r\n  # set the default role type only for this class\r\n  self.default_role_type = :module # also :wrap, :wrapper, or :interface\r\n\r\n  # shortcut initialization code\r\n  initialize(:activator, :account)\r\n  # or handle it yourself\r\n  def initialize(activator, account)\r\n    # this must be done to handle the mapping of roles to objects\r\n    # pass an array of arrays with role name symbol and the object for that role\r\n    map_roles([[:activator, activator],[:account, account]])\r\n\r\n    # or load extra objects, perform other functions, etc. if you need and then use super\r\n    account.perform_some_funtion\r\n    super\r\n  end\r\n  # these also must be done if you create your own initialize method.\r\n  # this is a shortcut for using attr_reader and private\r\n  private_attr_reader :activator, :account\r\n  \r\n  # initialize with keyword arguments\r\n  keyword_initialize(:activator, :account)\r\n  # this makes the following instance method signature with required keyword arguments\r\n  def initialize(activator:, account:)\r\n    # ...\r\n  end\r\n\r\n  role :activator do # module by default\r\n    def some_behavior; end\r\n  end\r\n\r\n  #  role_methods :activator, :module do # alternatively use role_methods if you choose\r\n  #    def some_behavior; end\r\n  #  end\r\n  #\r\n  #  role :activator, :wrap do\r\n  #    def some_behavior; end\r\n  #  end\r\n  #\r\n  #  role :activator, :interface do\r\n  #    def some_behavior; end\r\n  #  end\r\n  #\r\n  # use your own classes if you don't want SimpleDelegator\r\n  # class SomeSpecialRole\r\n  #   include Surrounded # <-- you must remember this in your own classes\r\n  #   # Surrounded assumes SomeSpecialRole.new(some_special_role)\r\n  #   def initialize(...);\r\n  #     # ... your code here\r\n  #   end\r\n  # end\r\n\r\n  # if you use a regular method and want to use context-specific behavior, \r\n  # you must handle storing the context yourself:\r\n  def regular_method\r\n    apply_behaviors # handles the adding of all the roles and behaviors\r\n    activator.some_behavior # behavior not available unless you apply roles on initialize\r\n  ensure\r\n     # Use ensure to enforce the removal of behaviors in case of exceptions.\r\n     # This also does not affect the return value of this method.\r\n    remove_behaviors # handles the removal of all roles and behaviors\r\n  end\r\n\r\n  # This trigger or the forward* methods are preferred for creating triggers.\r\n  trigger :some_trigger_method do\r\n    activator.some_behavior # behavior always available\r\n  end\r\n  \r\n  trigger def some_other_trigger\r\n    activator.some_behavior # behavior always available\r\n  end\r\n  \r\n  def regular_non_trigger\r\n    activator.some_behavior # behavior always available with the following line\r\n  end\r\n  trigger :regular_non_trigger # turns the method into a trigger\r\n  \r\n  # create restrictions on what triggers may be used\r\n  protect_triggers # <-- this is required if you want to protect your triggers this way.\r\n  disallow :some_trigger_method do\r\n    # whatever conditional code for the instance of the context\r\n  end\r\n  # you could also use `guard` instead of `disallow`\r\n  \r\n  # or define your own method without the `disallow` keyword\r\n  def disallow_some_trigger_method?\r\n    # whatever conditional code for the instance of the context\r\n  end\r\n  # Prefer using `disallow` because it will wrap role players in their roles for you;\r\n  # the `disallow_some_trigger_method?` defined above, does not.\r\n  \r\n  # Create shortcuts for triggers as class methods\r\n  # so you can do ActiviatingAccount.some_trigger_method(activator, account)\r\n  # This will make all triggers shortcuts.\r\n  shortcut_triggers\r\n  # Alterantively, you could implement shortcuts individually:\r\n  def self.some_trigger_method(activator, account)\r\n    instance = self.new(activator, account)\r\n    instance.some_trigger_method\r\n  end\r\n  \r\n  # Set triggers to always return the context object\r\n  # so you can enforce East-oriented style or Tell, Don't Ask\r\n  east_oriented_triggers\r\n  \r\n  # Forward context instance methods as triggers to role players\r\n  forward_trigger :role_name, :method_name\r\n  forward_trigger :role_name, :method_name, :alternative_trigger_name_for_method_name\r\n  forward_triggers :role_name, :list, :of, :methods, :to, :forward\r\n  forwarding [:list, :of, :methods, :to, :forward] => :role_name\r\nend\r\n\r\n# with keyword_initialize (will be changed to initialize)\r\ncontext = ActiviatingAccount.new(activator: some_object, account: some_account)\r\n# with initialize (this will be moved to initialize_without_keywords)\r\ncontext = ActiviatingAccount.new(some_object, some_account)\r\ncontext.triggers # => lists a Set of triggers\r\n# when using protect_triggers\r\ncontext.triggers # => lists a Set of triggers which may currently be called\r\ncontext.triggers # => lists a Set of all triggers (the same as if protect_triggers was _not_ used)\r\ncontext.allow?(:trigger_name) # => returns a boolean if the trigger may be run\r\n\r\n# reuse the context object with new role players\r\ncontext.rebind(activator: another_object, account: another_account)\r\n```\r\n\r\n## Dependencies\r\n\r\nThe dependencies are minimal. The plan is to keep it that way but allow you to configure things as you need. The [Triad](http://github.com/saturnflyer/triad) project was written specifically to manage the mapping of roles and objects to the modules which contain the behaviors. It is used in Surrounded to keep track of role player, roles, and role constant names but it is not a hard requirement. You may implement your own but presently you'll need to dive into the implementation to fully understand how. Future updates may provide better support and guidance.\r\n\r\nIf you're using [Casting](http://github.com/saturnflyer/casting), for example, Surrounded will attempt to use that before extending an object, but it will still work without it.\r\n\r\n## Support for other ways to apply behavior\r\n\r\nSurrounded is designed to be flexible for you. If you have your own code to manage applying behaviors, you can setup your context class to use it.\r\n\r\n### Additional libraries\r\n\r\nHere's an example using [Behavioral](https://github.com/saturnflyer/behavioral)\r\n\r\n```ruby\r\nclass MyCustomContext\r\n  extend Surrounded::Context\r\n\r\n  initialize :employee, :boss\r\n\r\n  def module_extension_methods\r\n    [:with_behaviors].concat(super)\r\n  end\r\n\r\n  def module_removal_methods\r\n    [:without_behaviors].concat(super)\r\n  end\r\nend\r\n```\r\n\r\nIf you're using your own non-SimpleDelegator wrapper you can conform to that; whatever it may be.\r\n\r\n```ruby\r\nclass MyCustomContext\r\n  extend Surrounded::Context\r\n\r\n  initialize :employee, :boss\r\n\r\n  class Employee < SuperWrapper\r\n    include Surrounded\r\n\r\n    # defined behaviors here...\r\n\r\n    def wrapped_object\r\n      # return the object that is wrapped\r\n    end\r\n\r\n  end\r\n\r\n  def unwrap_methods\r\n    [:wrapped_object]\r\n  end\r\nend\r\n```\r\n\r\n### Applying individual roles\r\n\r\nIf you'd like to use a special approach for just a single role, you may do that too.\r\n\r\nWhen applying behaviors from a role to your role players, your Surrounded context will first look for a method named  `\"apply_behavior_#{role}\"`. Define your own method and set it to accept 2 arguments: the role constant and the role player.\r\n\r\n```ruby\r\nclass MyCustomContext\r\n  extend Surrounded::Context\r\n\r\n  initialize :employee, :boss\r\n\r\n  def apply_behavior_employee(behavior_constant, role_player)\r\n    behavior_constant.build(role_player).apply # or whatever your need to do with your constant and object.\r\n  end\r\nend\r\n```\r\n\r\nYou can also plan for special ways to remove behavior as well.\r\n\r\n```ruby\r\nclass MyCustomContext\r\n  extend Surrounded::Context\r\n\r\n  initialize :employee, :boss\r\n\r\n  def remove_behavior_employee(behavior_constant, role_player)\r\n    role_player.cleanup # or whatever your need to do with your constant and object.\r\n  end\r\nend\r\n```\r\n\r\nYou can remember the method name by the convention that `remove` or `apply` describes it's function, `behavior` refers to the first argument (thet contsant holding the behaviors), and then the name of the role which refers to the role playing object: `remove_behavior_role`.\r\n\r\n## How to read this code\r\n\r\nIf you use this library, it's important to understand it.\r\n\r\nAs much as possible, when you use the Surrounded DSL for creating triggers, roles, initialize methods, and others you'll likely fine the actual method definitions created in a module and then find that module included in your class.\r\n\r\nThis is a design choice which allows you to override any standard behavior more easily.\r\n\r\n### Where methods exist and why\r\n\r\nWhen you define an initialize method for a Context class, Surrounded _could_ define the method on your class like this:\r\n\r\n```ruby\r\ndef initialize(*roles)\r\n  self.class_eval do # <=== this evaluates on _your_ class and defines it there.\r\n    # code...\r\n  end\r\nend\r\n```\r\n\r\nIf we used the above approach, you'd need to redefine initialize in its entirety:\r\n\r\n```ruby\r\ninitialize(:role1, role2)\r\n\r\ndef initialize(role1, role2) # <=== this will completely redefine initialize on _this class_\r\n  super # <=== this will NOT be the initialize method as provided to the Surrounded initialize above.\r\nend\r\n```\r\n\r\nSurrounded uses a more flexible approach for you:\r\n\r\n```ruby\r\ndef initialize(*roles)\r\n  mod = Module.new\r\n  mod.class_eval do # <=== this evaluates on the module and defines it there.\r\n    # code...\r\n  end\r\n  include mod # <=== this adds it to the class ancestors\r\nend\r\n```\r\n\r\nWith this approach you can use the way Surrounded is setup, but make changes if you need.\r\n\r\n```ruby\r\ninitialize(:role1, :role2) # <=== defined in a module in the class ancestors\r\n\r\ndef initialize(role1, role2)\r\n  super # <=== run the method as defined above in the Surrounded DSL\r\n  # ... then do additional work\r\nend\r\n```\r\n\r\n### Read methods, expect modules\r\n\r\nWhen you go to read the code, expect to find behavior defined in modules.\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem 'surrounded'\r\n```\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install surrounded\r\n    \r\n## Installation for Rails\r\n\r\nSee [surrounded-rails](https://github.com/saturnflyer/surrounded-rails)\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}