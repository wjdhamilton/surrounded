{"name":"Surrounded","tagline":"Gives an object implicit access to other objects in it's environment.","body":"# Surrounded\r\n\r\n[![Build Status](https://travis-ci.org/saturnflyer/surrounded.png?branch=master)](https://travis-ci.org/saturnflyer/surrounded)\r\n[![Code Climate](https://codeclimate.com/github/saturnflyer/surrounded.png)](https://codeclimate.com/github/saturnflyer/surrounded)\r\n[![Coverage Status](https://coveralls.io/repos/saturnflyer/surrounded/badge.png)](https://coveralls.io/r/saturnflyer/surrounded)\r\n[![Gem Version](https://badge.fury.io/rb/surrounded.png)](http://badge.fury.io/rb/surrounded)\r\n\r\n## Create encapsulated environments for your objects.\r\n\r\nKeep the distraction of other features out of your way. Write use cases and focus on just the business logic\r\n\r\n## Usage\r\n\r\nAdd `Surrounded` to your objects to give them awareness of other objects.\r\n\r\n```ruby\r\nclass User\r\n  include Surrounded\r\nend\r\n```\r\n\r\nNow your user instances will be able to get objects in their environment.\r\n\r\n_What environment!? I don't get it._\r\n\r\nI didn't explain that yet.\r\n\r\nYou can make an object which contains other objects. It acts as an environment\r\nand objects inside should have knowledge of the other objects in the environment.\r\nTake a breath, because there's a lot going on.\r\n\r\nFirst, you extend a class with the appropriate module to turn it into an object environment:\r\n\r\n```ruby\r\nclass MyEnvironment\r\n  extend Surrounded::Context\r\nend\r\n```\r\n\r\nTypical initialization of this environment has a lot of code. For example:\r\n\r\n```ruby\r\nclass MyEnvironment\r\n  extend Surrounded::Context\r\n\r\n  attr_reader :employee, :boss\r\n  private :employee, :boss\r\n  def initialize(employee, boss)\r\n    @employee = employee.extend(Employee)\r\n    @boss = boss\r\n  end\r\n\r\n  module Employee\r\n    # extra behavior here...\r\n  end\r\nend\r\n```\r\n\r\n_WTF was all that!?_\r\n\r\nRelax. I'll explain.\r\n\r\nWhen you create an instance of `MyEnvironment` it has certain objects inside.\r\nHere we see that it has an `employee` and a `boss`. Inside the methods of the environment it's simpler and easier to write `employee` instead of `@employee` so we make them `attr_reader`s. But we don't need these methods to be externally accessible so we set them to private.\r\n\r\nNext, we want to add environment-specific behavior to the `employee` so we extend the object with the module `Employee`.\r\n\r\nIf you're going to be doing this a lot, it's painful. Here's what `Surrounded` does for you:\r\n\r\n```ruby\r\nclass MyEnvironment\r\n  extend Surrounded::Context\r\n\r\n  initialize(:employee, :boss)\r\n\r\n  module Employee\r\n    # extra behavior here...\r\n  end\r\nend\r\n```\r\n\r\nThere! All that boilerplate code is cleaned up.\r\n\r\nNotice that there's no `Boss` module. If a module of that name does not exist, the object passed into initialize simply won't gain any new behavior.\r\n\r\n_OK. I think I get it, but what about the objects? How are they aware of their environment? Isn't that what this is supposed to do?_\r\n\r\nYup. Ruby doesn't have a notion of a local environment, so we lean on `method_missing` to do the work for us.\r\n\r\n```ruby\r\nclass User\r\n  include Surrounded\r\nend\r\n```\r\n\r\nWith that, all instances of `User` have implicit access to their surroundings.\r\n\r\n_Yeah... How?_\r\n\r\nVia `method_missing` those `User` instances can access a `context` object it stores in a `@__surroundings__` collection. I didn't mention how the context is set, however.\r\n\r\nYour environment will have methods of it's own that will trigger actions on the objects inside, but we need those trigger methods to set the environment instance as the current context so that the objects it contains can access them.\r\n\r\nHere's an example of what we want:\r\n\r\n```ruby\r\nclass MyEnvironment\r\n  # other stuff from above is still here...\r\n\r\n  def shove_it\r\n    employee.store_context(self)\r\n    employee.quit\r\n    employee.remove_context\r\n  end\r\n\r\n  module Employee\r\n    def quit\r\n      say(\"I'm sick of this place, #{boss.name}!\")\r\n      stomp\r\n      throw_papers\r\n      say(\"I quit!\")\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nWhat's happening in there is that when the `shove_it` method is called, the current environment object is stored as the context.\r\n\r\nThe behavior defined in the `Employee` module assumes that it may access other objects in it's local environment. The `boss` object, for example, is never explicitly passed in as an argument.\r\n\r\n_WTF!? That's insane!_\r\n\r\nI thought so too, at first. But continually passing references assumes there's no relationship between objects in that method. What `Surrounded` does for us is to make the relationship between objects and gives them the ability to access each other.\r\n\r\nThis simple example may seem trivial, but the more contextual code you have the more cumbersome passing references becomes. By moving knowledge to the local environment, you're free to make changes to the procedures without the need to alter method signatures with new refrences or the removal of unused ones.\r\n\r\nBy using `Surrounded::Context` you are declaring a relationship between the objects inside.\r\n\r\nBecause all the behavior is defined internally and only relevant internally, those relationships don't exist outside of the environment.\r\n\r\n_OK. I think I understand. So I can change business logic just by changing the procedures and the objects. I don't need to adjust arguments for a new requirement. That's kind of cool!_\r\n\r\nDamn right.\r\n\r\nBut you don't want to continually set those context details, do you?\r\n\r\n_No. That's annoying._\r\n\r\nYeah. Instead, it would be easier to have this library do the work for us.\r\nHere's what you can do:\r\n\r\n```ruby\r\nclass MyEnvironment\r\n  # the other code from above...\r\n\r\n  trigger :shove_it do\r\n    employee.quit\r\n  end\r\nend\r\n```\r\n\r\nBy using this `trigger` keyword, our block is the code we care about, but internally the method is written to set the `@__surroundings__` collection.\r\n\r\n_Hmm. I don't like having to do that._\r\n\r\nMe either. I'd rather just use `def` but getting automatic code for setting the context is really convenient.\r\nIt also allows us to store the triggers so that you can, for example, provide details outside of the environment about what triggers exist.\r\n\r\n```ruby\r\ncontext = MyEnvironment.new(current_user, the_boss)\r\ncontext.triggers #=> [:shove_it]\r\n```\r\n\r\nYou might find that useful for dynamically defining user interfaces.\r\n\r\n## Policies for the application of role methods\r\n\r\nThere are 2 approaches to applying new behavior to your objects.\r\n\r\nBy default your context will add methods to an object before a trigger is run\r\nand behaviors will be removed after the trigger is run.\r\n\r\nAlternatively you may set the behaviors to be added during the initialize method\r\nof your context.\r\n\r\nHere's how it works:\r\n\r\n```ruby\r\nclass ActiviatingAccount\r\n  extend Surrounded::Context\r\n\r\n  apply_roles_on(:trigger) # this is the default\r\n  # apply_roles_on(:initialize) # set this to apply behavior from the start\r\n\r\n  initialize(:activator, :account)\r\n\r\n  module Activator\r\n    def some_behavior; end\r\n  end\r\n\r\n  def non_trigger_method\r\n    activator.some_behavior # not available unless you apply roles on initialize\r\n  end\r\n\r\n  trigger :some_trigger_method do\r\n    activator.some_behavior # always available\r\n  end\r\nend\r\n```\r\n\r\n_Why are those options there?_\r\n\r\nWhen you initialize a context and apply behavior at the same time, you'll need\r\nto remove that behavior. For example, if you are using Casting AND you apply roles on initialize:\r\n\r\n```ruby\r\ncontext = ActiviatingAccount.new(current_user, Account.find(123))\r\ncontext.do_something\r\ncurrent_user.some_behavior # this method is still available\r\ncurrent_user.uncast # you'll have to manually cleanup\r\n```\r\n\r\nBut if you go with the default and apply behaviors on trigger, your roles will be cleaned up automatically:\r\n\r\n```ruby\r\ncontext = ActiviatingAccount.new(current_user, Account.find(123))\r\ncontext.do_something\r\ncurrent_user.some_behavior # NoMethodError\r\n```\r\n\r\n## How's the performance?\r\n\r\nI haven't really tested yet, but there are several ways you can add behavior to your objects.\r\n\r\nThere are a few defaults built in.\r\n\r\n1. If you define modules for the added behavior, the code will run `object.extend(RoleInterface)`\r\n2. If you are using [casting](http://github.com/saturnflyer/casting), the code will run `object.cast_as(RoleInterface)`\r\n3. If you would rather use wrappers you can define classes and the code will run `RoleInterface.new(object)` and assumes that the `new` method takes 1 argument. You'll need to remember to `include Surrounded` in your classes, however.\r\n4. If you want to use wrappers but would rather not muck about with including modules and whatnot, you can define them like this:\r\n\r\n```\r\nclass SomeContext\r\n  extend Surrounded::Context\r\n\r\n  initialize(:admin, :user)\r\n\r\n  wrap :admin do\r\n    # special methods defined here\r\n  end\r\n```\r\n\r\nThe `wrap` method will create a class of the given name (`Admin` in this case) and will inherit from `SimpleDelegator` from the Ruby standard library _and_ will `include Surrounded`.\r\n\r\nLastly, there's a 5th option if you're using Ruby 2.x: `interface`.\r\n\r\nThe `interface` method acts similarly to the `wrap` method in that it returns an object that is not actually the object you want. But an `interface` is different in that it will apply methods from a module instead of using methods defined in a SimpleDelegator subclass. How is that important? Well you are free to use things like instance variables in your methods because they will be executed in the context of the object. This is unlike methods in a SimpleDelegator where the wrapper maintains its own instance variables.\r\n\r\n_Which should I use?_\r\n\r\nStart with the default and see how it goes, then try another approach and measure the changes.\r\n\r\n## Dependencies\r\n\r\nThe dependencies are minimal. The plan is to keep it that way but allow you to configure things as you need.\r\n\r\nIf you're using [Casting](http://github.com/saturnflyer/casting), for example, Surrounded will attempt to use that before extending an object, but it will still work without it.\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem 'surrounded'\r\n```\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install surrounded\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}