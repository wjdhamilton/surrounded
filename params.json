{"name":"Surrounded","tagline":"Gives an object implicit access to other objects in it's environment.","body":"# ![Surrounded](http://saturnflyer.github.io/surrounded/images/surrounded.png \"Surrounded\")\r\n## Bring your own complexity\r\n\r\n[![Build Status](https://travis-ci.org/saturnflyer/surrounded.png?branch=master)](https://travis-ci.org/saturnflyer/surrounded)\r\n[![Code Climate](https://codeclimate.com/github/saturnflyer/surrounded.png)](https://codeclimate.com/github/saturnflyer/surrounded)\r\n[![Coverage Status](https://coveralls.io/repos/saturnflyer/surrounded/badge.png)](https://coveralls.io/r/saturnflyer/surrounded)\r\n[![Gem Version](https://badge.fury.io/rb/surrounded.png)](http://badge.fury.io/rb/surrounded)\r\n\r\n# Surrounded aims to make things simple and get out of your way.\r\n\r\nMost of what you care about is defining the behavior of objects. How they interact is important.\r\nThe purpose of this library is to clear away the details of getting things setup and to allow you to make changes to the way you handle roles.\r\n\r\nThere are two main parts to this library. \r\n\r\n1. `Surrounded` gives objects an implicit awareness of other objects in their environments.\r\n2. `Surrounded::Context` helps you create objects which encapsulate other objects. These *are* the environments.\r\n\r\nFirst, take a look at creating contexts. This is where you'll spend most of your time.\r\n\r\n## Easily create encapsulated environments for your objects.\r\n\r\nTypical initialization of an environment, or a Context in DCI, has a lot of code. For example:\r\n\r\n```ruby\r\nclass MyEnvironment\r\n\r\n  attr_reader :employee, :boss\r\n  private :employee, :boss\r\n  def initialize(employee, boss)\r\n    @employee = employee.extend(Employee)\r\n    @boss = boss\r\n  end\r\n\r\n  module Employee\r\n    # extra behavior here...\r\n  end\r\nend\r\n```\r\n\r\nThis code allows the MyEnvironment class to create instances where it will have an `employee` and a `boss` role internally. These are set to `attr_reader`s and are made private.\r\n\r\nThe `employee` is extended with behaviors defined in the `Employee` module, and in this case there's no extra stuff for the `boss` so it doesn't get extended with anything.\r\n\r\nMost of the time you'll follow a pattern like this. Some objects will get extra behavior and some won't. The modules that you use to provide the behavior will match the names you use for the roles to which you assign objects.\r\n\r\nBy adding `Surrounded::Context` you can shortcut all this work.\r\n\r\n```ruby\r\nclass MyEnvironment\r\n  extend Surrounded::Context\r\n  \r\n  initialize(:employee, :boss)\r\n\r\n  module Employee\r\n    # extra behavior here...\r\n  end\r\nend\r\n```\r\n\r\nSurrounded gives you an `initialize` class method which does all the setup work for you.\r\n\r\n## Managing Roles\r\n\r\n_I don't want to use modules. Can't I use something like SimpleDelegator?_\r\n\r\nWell, it just so happens that you can. This code will work just fine:\r\n\r\n```ruby\r\nclass MyEnvironment\r\n  extend Surrounded::Context\r\n  \r\n  initialize(:employee, :boss)\r\n\r\n  class Employee < SimpleDelegator\r\n    # extra behavior here...\r\n  end\r\nend\r\n```\r\n\r\nInstead of extending the `employee` object, Surrounded will run `Employee.new(employee)` to create the wrapper for you. You'll need to include the `Surrounded` module in your wrapper, but we'll get to that.\r\n\r\nBut the syntax can be even simpler than that if you want.\r\n\r\n```ruby\r\nclass MyEnvironment\r\n  extend Surrounded::Context\r\n  \r\n  initialize(:employee, :boss)\r\n\r\n  role :employee do\r\n    # extra behavior here...\r\n  end\r\nend\r\n```\r\n\r\nBy default, this code will create a module for you named `Employee`. If you want to use a wrapper, you can do this:\r\n\r\n```ruby\r\nclass MyEnvironment\r\n  extend Surrounded::Context\r\n  \r\n  initialize(:employee, :boss)\r\n\r\n  wrap :employee do\r\n    # extra behavior here...\r\n  end\r\nend\r\n```\r\n\r\nBut if you're making changes and you decide to move from a module to a wrapper or from a wrapper to a module, you'll need to change that method call. Instead, you could just tell it which type of role to use:\r\n\r\n```ruby\r\nclass MyEnvironment\r\n  extend Surrounded::Context\r\n  \r\n  initialize(:employee, :boss)\r\n\r\n  role :employee, :wrapper do\r\n    # extra behavior here...\r\n  end\r\nend\r\n```\r\n\r\nThe default available types are `:module`, `:wrap` or `:wrapper`, and `:interface`. We'll get to `interface` below. The `:wrap` and `:wrapper` types are the same and they'll both create classes which inherit from SimpleDelegator _and_ include Surrounded for you.\r\n\r\nThese are minor little changes which highlight how simple it is to use Surrounded.\r\n\r\n_Well... I want to use [Casting](https://github.com/saturnflyer/casting) so I get the benefit of modules without extending objects. Can I do that?_\r\n\r\nYup. The ability to use Casting is built-in. If the objects you provide to your context respond to `cast_as` then Surrounded will use that.\r\n\r\n_Ok. So is that it?_\r\n\r\nThere's a lot more. Let's look at the individual objects and what they need for this to be valuable...\r\n\r\n## Objects' access to their environments\r\n\r\nAdd `Surrounded` to your objects to give them awareness of other objects.\r\n\r\n```ruby\r\nclass User\r\n  include Surrounded\r\nend\r\n```\r\n\r\nNow the `User` instances will be able to implicitly access objects in their environment.\r\n\r\nVia `method_missing` those `User` instances can access a `context` object it stores in an internal collection. \r\n\r\nInside of the `MyEnvironment` context we saw above, the `employee` and `boss` objects are instances of `User` for this example.\r\n\r\nBecause the `User` class includes `Surrounded`, the instances of that class will be able to access other objects in the same context implicitly.\r\n\r\nLet's make our context look like this:\r\n\r\n```ruby\r\nclass MyEnvironment\r\n  # other stuff from above is still here...\r\n\r\n  def shove_it\r\n    employee.quit\r\n  end\r\n\r\n  role :employee do\r\n    def quit\r\n      say(\"I'm sick of this place, #{boss.name}!\")\r\n      stomp\r\n      throw_papers\r\n      say(\"I quit!\")\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nWhat's happening in there is that when the `shove_it` method is called on the instance of `MyEnvironment`, the `employee` has the ability to refer to `boss` because it is in the same context, e.g. the same environment.\r\n\r\nThe behavior defined in the `Employee` module assumes that it may access other objects in it's local environment. The `boss` object, for example, is never explicitly passed in as an argument.\r\n\r\nWhat `Surrounded` does for us is to make the relationship between objects and gives them the ability to access each other. Adding new or different roles to the context now only requires that we add them to the context and nothing else. No explicit references must be passed to each individual method. The objects are aware of the other objects around them and can refer to them by their role name.\r\n\r\nI didn't mention how the context is set, however.\r\n\r\n## Tying objects together\r\n\r\nYour context will have methods of it's own which will trigger actions on the objects inside, but we need those trigger methods to set the accessible context for each of the contained objects.\r\n\r\nHere's an example of what we want:\r\n\r\n```ruby\r\nclass MyEnvironment\r\n  # other stuff from above is still here...\r\n\r\n  def shove_it\r\n    employee.store_context(self)\r\n    employee.quit\r\n    employee.remove_context\r\n  end\r\n\r\n  role :employee do\r\n    def quit\r\n      say(\"I'm sick of this place, #{boss.name}!\")\r\n      stomp\r\n      throw_papers\r\n      say(\"I quit!\")\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nNow that the `employee` has a reference to the context, it won't blow up when it hits `boss` inside that `quit` method.\r\n\r\nWe saw how we were able to clear up a lot of that repetitive work with the `initialize` method, so this is how we do it here:\r\n\r\n```ruby\r\nclass MyEnvironment\r\n  # other stuff from above is still here...\r\n\r\n  trigger :shove_it do\r\n    employee.quit\r\n  end\r\n\r\n  role :employee do\r\n    def quit\r\n      say(\"I'm sick of this place, #{boss.name}!\")\r\n      stomp\r\n      throw_papers\r\n      say(\"I quit!\")\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nBy using this `trigger` keyword, our block is the code we care about, but internally the method is created to first set all the objects' current contexts.\r\n\r\nThe context will also store the triggers so that you can, for example, provide details outside of the environment about what triggers exist.\r\n\r\n```ruby\r\ncontext = MyEnvironment.new(current_user, the_boss)\r\ncontext.triggers #=> [:shove_it]\r\n```\r\n\r\nYou might find that useful for dynamically defining user interfaces.\r\n\r\nSometimes I'd rather not use this DSL, however. I want to just write regular methods. \r\n\r\nWe can do that too. You'll need to opt in to this by specifying `set_methods_as_triggers` for the context class.\r\n\r\n```ruby\r\nclass MyEnvironment\r\n  # other stuff from above is still here...\r\n  \r\n  set_methods_as_triggers\r\n\r\n  def shove_it\r\n    employee.quit\r\n  end\r\n\r\n  role :employee do\r\n    def quit\r\n      say(\"I'm sick of this place, #{boss.name}!\")\r\n      stomp\r\n      throw_papers\r\n      say(\"I quit!\")\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThis will allow you to write methods like you normally would. They are aliased internally with a prefix and the method name that you use is rewritten to add and remove the context for the objects in this context. The public API of your class remains the same, but the extra feature of wrapping your method is handled for you.\r\n\r\nThis will treat all instance methods defined on your context the same way, so be aware of that.\r\n\r\n## Where roles exist\r\n\r\nBy using `Surrounded::Context` you are declaring a relationship between the objects inside playing your defined roles.\r\n\r\nBecause all the behavior is defined internally and only relevant internally, those relationships don't exist outside of the environment.\r\n\r\nSurrounded makes all of your role modules and classes private constants. It's not a good idea to try to reuse behavior defined for one context in another area.\r\n\r\n## The role DSL\r\n\r\nUsing the `role` method to define modules and classes takes care of the setup for you. This way you can swap between implementations:\r\n\r\n```ruby\r\n\r\n  # this uses modules\r\n  role :source do\r\n    def transfer\r\n      self.balance -= amount\r\n      destination.balance += amount\r\n      self\r\n    end\r\n  end\r\n\r\n  # this uses SimpleDelegator and Surrounded\r\n  role :source, :wrap do\r\n    def transfer\r\n      self.balance -= amount\r\n      destination.balance += amount\r\n      __getobj__\r\n    end\r\n  end\r\n\r\n  # this uses a special interface object which pulls\r\n  # methods from a module and applies them to your object.\r\n  role :source, :interface do\r\n    def transfer\r\n      self.balance -= amount\r\n      destination.balance += amount\r\n      self\r\n    end\r\n  end\r\n```\r\n\r\nThe `:interface` option is a special object which has all of its methods removed (excepting `__send__` and `object_id`) so that other methods will be pulled from the ones that you define, or from the object it attempts to proxy.\r\n\r\nNotice that the `:interface` allows you to return `self` whereas the `:wrap` acts more like a wrapper and forces you to deal with that shortcoming by using it's wrapped-object-accessor method: `__getobj__`.\r\n\r\nIf you'd like to choose one and use it all the time, you can set the default:\r\n\r\n```ruby\r\nclass MoneyTransfer\r\n  extend Surrounded::Context\r\n\r\n  self.default_role_type = :interface # also :wrap, :wrapper, or :module\r\n\r\n  role :source do\r\n    def transfer\r\n      self.balance -= amount\r\n      destination.balance += amount\r\n      self\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nOr, if you like, you can choose the default for your entire project:\r\n\r\n```ruby\r\nSurrounded::Context.default_role_type = :interface\r\n\r\nclass MoneyTransfer\r\n  extend Surrounded::Context\r\n\r\n  role :source do\r\n    def transfer\r\n      self.balance -= amount\r\n      destination.balance += amount\r\n      self\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n## Policies for the application of role methods\r\n\r\nThere are 2 approaches to applying new behavior to your objects.\r\n\r\nBy default your context will add methods to an object before a trigger is run\r\nand behaviors will be removed after the trigger is run.\r\n\r\nAlternatively you may set the behaviors to be added during the initialize method\r\nof your context.\r\n\r\nHere's how it works:\r\n\r\n```ruby\r\nclass ActiviatingAccount\r\n  extend Surrounded::Context\r\n\r\n  apply_roles_on(:trigger) # this is the default\r\n  # apply_roles_on(:initialize) # set this to apply behavior from the start\r\n\r\n  initialize(:activator, :account)\r\n\r\n  role :activator do\r\n    def some_behavior; end\r\n  end\r\n\r\n  def non_trigger_method\r\n    activator.some_behavior # not available unless you apply roles on initialize\r\n  end\r\n\r\n  trigger :some_trigger_method do\r\n    activator.some_behavior # always available\r\n  end\r\nend\r\n```\r\n\r\n_Why are those options there?_\r\n\r\nWhen you initialize a context and apply behavior at the same time, you'll need\r\nto remove that behavior. For example, if you are using Casting AND you apply roles on initialize:\r\n\r\n```ruby\r\ncontext = ActiviatingAccount.new(current_user, Account.find(123))\r\ncontext.do_something\r\ncurrent_user.some_behavior # this method is still available\r\ncurrent_user.uncast # you'll have to manually cleanup\r\n```\r\n\r\nBut if you go with the default and apply behaviors on trigger, your roles will be cleaned up automatically:\r\n\r\n```ruby\r\ncontext = ActiviatingAccount.new(current_user, Account.find(123))\r\ncontext.do_something\r\ncurrent_user.some_behavior # NoMethodError\r\n```\r\n\r\n## Overview in code\r\n\r\nHere's a view of the possibilities in code.\r\n\r\n```ruby\r\n# set default role type for *all* contexts in your program\r\nSurrounded::Context.default_role_type = :module # also :wrap, :wrapper, or :interface\r\n\r\nclass ActiviatingAccount\r\n  extend Surrounded::Context\r\n\r\n  apply_roles_on(:trigger) # this is the default\r\n  # apply_roles_on(:initialize) # set this to apply behavior from the start\r\n  \r\n  set_methods_as_triggers # allows you to skip the 'trigger' dsl\r\n  \r\n  # set the default role type only for this class\r\n  self.default_role_type = :module # also :wrap, :wrapper, or :interface\r\n\r\n  initialize(:activator, :account)\r\n\r\n  role :activator do # module by default\r\n    def some_behavior; end\r\n  end\r\n\r\n  #  role :activator, :module do\r\n  #    def some_behavior; end\r\n  #  end\r\n  #\r\n  #  role :activator, :wrap do\r\n  #    def some_behavior; end\r\n  #  end\r\n  #\r\n  #  role :activator, :interface do\r\n  #    def some_behavior; end\r\n  #  end\r\n  #\r\n  # use your own classes if you don't want SimpleDelegator\r\n  # class SomeSpecialRole\r\n  #   include Surrounded # you must remember this\r\n  #   # Surrounded assumes SomeSpecialRole.new(some_special_role)\r\n  #   def initialize(...);\r\n  #     # ... your code here\r\n  #   end\r\n  # end\r\n\r\n  # works as a trigger (assigning the current context) only if set_methods_as_triggers is set\r\n  def regular_method\r\n    activator.some_behavior # behavior not available unless you apply roles on initialize\r\n  end\r\n\r\n  trigger :some_trigger_method do\r\n    activator.some_behavior # behavior always available\r\n  end\r\nend\r\n```\r\n\r\n## Dependencies\r\n\r\nThe dependencies are minimal. The plan is to keep it that way but allow you to configure things as you need. The [Triad](http://github.com/saturnflyer/triad) project was written specifically to manage the mapping of roles and objects to the modules which contain the behaviors.\r\n\r\nIf you're using [Casting](http://github.com/saturnflyer/casting), for example, Surrounded will attempt to use that before extending an object, but it will still work without it.\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem 'surrounded'\r\n```\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install surrounded\r\n    \r\n## Installation for Rails\r\n\r\nSee [surrounded-rails](https://github.com/saturnflyer/surrounded-rails)\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}